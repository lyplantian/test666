<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <meta content="width=device-width, initial-scale=1,maximum-scale=1,user-scalable=no" name="viewport">
    <meta content="yes" name="apple-mobile-web-app-capable">

    <!--在您实际的项目中,请留意mescroll-option.css的图片路径是否引用正确,可写成绝对路径或网络地址-->
    <!--可把mescroll-option.css代码拷贝到mescroll.min.css中,合为一个css文件,方便引用-->
    <link href="../dist/mescroll.min.css" rel="stylesheet">
    <link href="option/mescroll-option.css" rel="stylesheet">
    <style type="text/css">
        * {
            margin: 0;
            padding: 0;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            background-color: white
        }

        ul {
            list-style-type: none
        }

        img {
            width: 100%;
            vertical-align: bottom;
        }


        /*列表*/
        .mescroll {
            position: fixed;
            top: 10px; /*top 和 bottom 的值根据情况定*/
            bottom: 10px;
            height: auto;
        }

        /*回到顶部按钮*/
        .mescroll-totop {
            bottom: 70px;
        }

        /*下拉刷新回调的提示*/
        .download-tip {
            z-index: 9900;
            position: fixed;
            top: 10px;
            left: 0;
            width: 100%;
            height: 30px;
            line-height: 30px;
            font-size: 12px;
            text-align: center;
            background-color: rgba(255, 130, 1, .7);
            color: white;
            -webkit-transition: top 300ms;
            transition: top 300ms;
        }

        /*展示上拉加载的数据列表*/
        .news-list li {
            padding: 16px;
            border-top: 1px solid #eee;
            border-bottom: 12px solid #eee;
        }

        .news-list .new-content {
            font-size: 14px;
            margin-top: 6px;
            margin-left: 8px;
            color: #666;
        }

        .news-list .new-title {
            font-size: 16px;
            color: #333333;
        }

    </style>
</head>

<body>

<div>

    <!--滑动区域-->
    <div class="mescroll" id="mescroll">
        <div>开始滑动了//////</div>
        <div>开始滑动了//////</div>
        <div>开始滑动了//////</div>
        <div>开始滑动了//////</div>
        <div>开始滑动了//////</div>
        <!--展示上拉加载的数据列表-->
        <ul class="news-list" id="newsList">
            <!--模拟的内容 显示20条-->
            <div>模拟的内容</div>
            <!-- <img src="img/xinlang1.jpg"/>
            <img src="img/xinlang2.jpg"/> -->
            <!--<li>
                <p>【微博1】标题标题标题标题</p>
                <p class="new-content">内容内容内容内容内容内容内容内容内容</p>
            </li>-->
        </ul>
    </div>
</div>


</body>

<!--在您实际的项目中,请留意mescroll-option.js的图片路径是否引用正确,可写成绝对路径或网络地址-->
<!--可把mescroll-option.js代码拷贝到mescroll.min.js中,合为一个js文件,方便引用-->

<script charset="utf-8" src="../dist/mescroll.min.js" type="text/javascript"></script>

<!--mescroll本身不依赖jq,这里为了模拟发送ajax请求-->
<script charset="utf-8" src="option/jquery-3.4.1.js" type="text/javascript"></script>
<script charset="utf-8" type="text/javascript">
    $(function () {
        //创建MeScroll对象
        var mescroll = initMeScroll("mescroll", {
            down: {
                auto: false,//是否在初始化完毕之后自动执行下拉回调callback; 默认true
                callback: downCallback, //下拉刷新的回调
            },
            up: {
                auto: true,//初始化完毕,是否自动触发上拉加载的回调
                isBoth: true, //上拉加载时,如果滑动到列表顶部是否可以同时触发下拉刷新;默认false,两者不可同时触发; 这里为了演示改为true,不必等列表加载完毕才可下拉;
                isBounce: false, //此处禁止ios回弹,解析(务必认真阅读,特别是最后一点): http://www.mescroll.com/qa.html#q10
                callback: upCallback, //上拉加载的回调
				page: {
				    num: 0, //当前页 默认0,回调之前会加1; 即callback(page)会从1开始
				    size: 10 //每页数据条数,默认10
				},
                toTop: { //配置回到顶部按钮
                    src: "../res/img/mescroll-totop.png", //默认滚动到1000px显示,可配置offset修改
                    //offset : 1000
                }
            }
        });

        /*下拉刷新的回调 */
        function downCallback() {
            //加载轮播数据..
            //...
            //加载列表数据
            getListDataFromNet(0, 1, function (data) {
                //设置列表数据
                setListData(data, false);
                //隐藏转圈，显示"刷新完成"
                $('.downwarp-onload .downwarp-progress').hide();
                $('.downwarp-onload .downwarp-tip2').text("刷新完成");

				//显示刷新完成一定时间后话刷新完成
                setTimeout(function () {
                    //联网成功的回调,隐藏下拉刷新的状态
                    mescroll.endSuccess();
                    setTimeout(function () {
                        //然后设置转圈显示，并显示文字"刷新中"
                        $('.downwarp-onload .downwarp-progress').show();
                        $('.downwarp-onload .downwarp-tip2').text("刷新中");
                    },300);
                }, 700);

            }, function () {
                //联网失败的回调,隐藏下拉刷新的状态
                mescroll.endErr();
            });
        }

        /*上拉加载的回调 page = {num:1, size:10}; num:当前页 从1开始, size:每页数据条数 */
        function upCallback(page) {

            //联网加载数据
            getListDataFromNet(page.num, page.size, function (curPageData) {
                //联网成功的回调,隐藏下拉刷新和上拉加载的状态;
                //mescroll会根据传的参数,自动判断列表如果无任何数据,则提示空;列表无下一页数据,则提示无更多数据;
                console.log("page.num=" + page.num + ", page.size=" + page.size + ", curPageData.length=" + curPageData.length);

                //方法一(推荐): 后台接口有返回列表的总页数 totalPage
                //mescroll.endByPage(curPageData.length, totalPage); //必传参数(当前页的数据个数, 总页数)

                //方法二(推荐): 后台接口有返回列表的总数据量 totalSize
                //mescroll.endBySize(curPageData.length, totalSize); //必传参数(当前页的数据个数, 总数据量)

                //方法三(推荐): 您有其他方式知道是否有下一页 hasNext(是否有更多数据)
                mescroll.endSuccess(curPageData.length, hasNext); //必传参数(当前页的数据个数, 是否有下一页true/false)

                //方法四 (不推荐),会存在一个小问题:比如列表共有20条数据,每页加载10条,共2页.如果只根据当前页的数据个数判断,则需翻到第三页才会知道无更多数据,如果传了hasNext,则翻到第二页即可显示无更多数据.
                // mescroll.endSuccess(curPageData.length);

                //提示:curPageData.length必传的原因:
                // 1.判断是否有下一页的首要依据: 当传的值小于page.size时,则一定会认为无更多数据.
                // 2.比传入的totalPage, totalSize, hasNext具有更高的判断优先级
                // 3.使配置的noMoreSize生效

                //设置列表数据
                setListData(curPageData, true);
            }, function () {
                //联网失败的回调,隐藏上拉加载的状态
                mescroll.endErr();
            });
        }

        /*设置列表数据*/
        function setListData(curPageData, isAppend) {
            var listDom = document.getElementById("newsList");
            for (var i = 0; i < curPageData.length; i++) {
                var newObj = curPageData[i];

                var str = '<p class="new-title">' + newObj.title + '</p>';
                str += '<p class="new-content">' + newObj.content + '</p>';
                var liDom = document.createElement("li");
                liDom.innerHTML = str;

                if (isAppend) {
                    listDom.appendChild(liDom);//加在列表的后面,上拉加载
                } else {
                    listDom.insertBefore(liDom, listDom.firstChild);//加在列表的前面,下拉刷新
                }
            }
        }

        /*联网加载列表数据
         在您的实际项目中,请参考官方写法: http://www.mescroll.com/api.html#tagUpCallback
         请忽略getListDataFromNet的逻辑,这里仅仅是在本地模拟分页数据,本地演示用
         实际项目以您服务器接口返回的数据为准,无需本地处理分页.
         * */
        var downIndex = 0;

        function getListDataFromNet(pageNum, pageSize, successCallback, errorCallback) {
            //延时一秒,模拟联网
            setTimeout(function () {
                try {
                    var newArr = [];
                   /* if (pageNum == 0) {
                        //此处模拟下拉刷新返回的数据
                        downIndex++;
                        var newObj = {title: "【新增微博" + downIndex + "】 新增微博", content: "新增微博的内容<br/>新增微博的内容"};
                        newArr.push(newObj);
                    } else {
                        //此处模拟上拉加载返回的数据
                        for (var i = 0; i < pageSize; i++) {
                            var upIndex = (pageNum - 1) * pageSize + i + 1;
                            var newObj = {title: "【微博" + upIndex + "】 标题标题标题标题标题标题", content: "内容内容内容内容内容内容内容内容内容内容"};
                            newArr.push(newObj);
                        }
                    }*/
                    //联网成功的回调
                    successCallback && successCallback(newArr);
                } catch (e) {
                    //联网失败的回调
                    errorCallback && errorCallback();
                }
            }, 2000)
        }

    });
</script>

</html>
